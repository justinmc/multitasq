// Task Model
var Multitasq_Task = Backbone.Model.extend({
    
    // config, default text in a task
    defaultTitle: 'New Task',

    // default attributes for the task
    defaults: function() {
      // get current date
      var date = this.getDateNow();
      
      return {
        kind: "tasks#task",
        id: '0',                  // FIXME you'll have to use the google task api to create a new id
        etag: '0',                // FIXME google task api
        title: this.defaultTitle,
        updated: date,
        selfLink: '0',            // FIXME google task api
        parent: -1,
        position: '0',            // FIXME google task api
        status: 'needsAction',
        completed: null,
        // not Google Tasks data, only Multitasq
        children: [],
        level: 0,
        minimized: false,
        upped: false
      };
    },

    // Set any defaults for new entries
    initialize: function(id, title) {
      if (!this.get("title")) {
        this.set({"title": this.defaults.title});
        this.set({"title": this.defaults.parent});
      }
    },
    
    // Toggle the minimized setting true/false
    toggleMinimized: function() {
        if (this.get("minimized") === false) {
            this.save({minimized: true});
        }
        else {
            this.save({minimized: false});
        }
    },
    
    // Toggle the updown setting true/false
    toggleUpdown: function() {
        if (this.get("upped") === false) {
            this.save({upped: true});
        }
        else {
            this.save({upped: false});
        }
    },

    // Toggle the completed state of the task
    toggleCompleted: function() {
        if (this.get("completed") === null) {
            this.setCompleted();
        }
        else {
            this.setIncomplete();
        }
    },

    // Set the task as completed
    setCompleted: function() {
        var date = this.getDateNow();
        this.save({completed: date});
        this.save({updated: date});
    },

    // Set the task as incomplete
    setIncomplete: function() {
        var date = this.getDateNow();
        this.save({completed: null});
           this.save({updated: date});
    },

    // Returns the current date formatted in Google Task's format
    getDateNow: function() {
        var now = new Date();
        var date = now.getUTCFullYear() + '-' + now.getUTCMonth() + '-' + now.getUTCDate() + 'T' + now.getUTCHours() + ':' + now.getUTCMinutes() + ':' + now.getUTCSeconds() + '.000Z';

        return date;
    },

    // Remove this task from localStorage and delete its view.
    clear: function() {
      this.destroy();
    }
});

// Task Collection

var Multitasq_TaskList = Backbone.Collection.extend({

    // Reference to this collection's model.
    model: Multitasq_Task,
    
    // Url to call to get the task list
    //url: '/js/tasklist_spread.json',

    // Save all of the todo items under the `"multitasq"` namespace.
    localStorage: new Backbone.LocalStorage("multitasq-backbone"),
    
    // Topmost node in the collection
    top: null,
    
    initialize: function(sandbox) {
        // Each time something gets changed, sync with localstorage
        this.bind('reset', function() {
            this.collectionUpdated(sandbox);
        });
        this.bind('add', function() {
            this.collectionUpdated(sandbox);
        });
        
        // Sync parent data and localstorage on remove (don't update view automatically though!)
        this.bind('remove', function(task) {
               // remove from parent's "children" data!
            var parent = this.get(task.get('parent'));
            if (typeof parent !== 'undefined') {
                var siblings = parent.get('children');
                siblings.splice($.inArray(task.get('id'), siblings), 1);
                parent.save({'children': siblings});
            }
            
            // delete from localstorage
            Backbone.sync('delete', task, {
                success: function() {return;},
                error: function() {return;}
            });
        });
    },
    
    // Sync the data and the UI
    collectionUpdated: function(sandbox) {
        // reset anything that will be recalculated here
        this.top = null;

        // if the collection is empty, initialize it with a cool starter!
        if (!this.length) {
            this.create({
                'id': this.newId(),
                'title': 'Conquer the world'
            });
        }
        
        // update data
        var tasks = this;
        var orphans = [];
        this.each(function(obj, key) {
            // set level
            var parent = tasks.get(obj.get('parent'));
            var level = ((typeof parent === 'undefined') || (parent === -1)) ? 0 : (parent.get('level') + 1);
            obj.save({'level': level});
            
            // add to parentless if it has no parent
            if ((typeof parent === 'undefined') || (parent === -1)) {
                orphans.push(obj.get("id"));
            }

            // if it has no parent or is upped, it could be the top node
            if ((orphans.indexOf(obj.get("id")) !== -1) || (obj.get("upped"))) {
                // if it's lower level than the current parent, set as top
                var parentLevel = (tasks.top === null) ? -Infinity : tasks.get(tasks.top).get("level");
                if (obj.get('level') > parentLevel) {
                    tasks.top = obj.get('id');
                }
            }
            
            // set children for parent if there is a parent
            if ((typeof parent !== 'undefined') && (parent !== -1)) {
                var siblings = parent.get('children');
                var id = obj.get('id');
                if ($.inArray(obj.get('id'), siblings) === -1) {
                    siblings.push(obj.get('id'));
                    parent.save({'children': siblings});
                }
            }
        });
        
        // if there are multiple top level nodes, create one parent for them all
        if (orphans.length > 1) {
            var id = this.newId();
        
            for (var i in orphans) {
                this.get(orphans[i]).save({'parent': id});
            }
        
            this.top = id;
            this.create({
                'id':         id,
                'parent':    -1,
                'title': 'Conquer the world'
            });
        }
        
        // update the view if what we created is valid
        if (this.isValidTree()) {
            sandbox.render();
        }
        // otherwise, clear all data
        else {
            alert("Error: Invalid data in localstorage, click OK to clear");
            localStorage.clear(); // FIXME better way to do this using backbone sync?
            this.reset();
        }
    },

    // Returns true if the collection is a valid tree, false otherwise
    // FIXME can't return false within loop, have to use this "valid" variable???
    isValidTree: function() {
        var valid = true;
        
        // make sure we have a top node
        if (this.top === null) {
            valid = false;
        }
        
        // check that all children ids exist
        var tasks = this;
        this.each(function(obj, key) {
            var children = obj.get('children');
            for (var i in children) {
                if (typeof tasks.get(children[i]) === 'undefined') {
                    valid = false;
                }
            }
        });

        return valid;
    },
    
    // Returns a unique id not currently in the collection that can be used to add a task
    newId: function() {
        var taskNewestId = this.length ? parseInt(this.get(this.at(this.length - 1)).get('id')) : 0;

        var id = taskNewestId + 1;
        var exists = true;
        while (exists) {
            if (!this.get(id)) {
                exists = false;
            }
            id++;
        }
        
        return id;
    },
    
    // Remove the task and all tasks below it, depth first recursively
    removeSubtree: function(task, sandbox) {
        // Call helper fn to actually remove the tasks recursively
        this.removeSubtreeRecurse(task);

        // Update the view
        this.collectionUpdated(sandbox);        
    },
    
    // Helper fn to removeSubtree, so that we can update the data afterwards
    // Note this is necessary for removing, but not for below changing complete status
    removeSubtreeRecurse: function(task) {
        // recursively remove all children (if any)
        var children = task.get('children');
        var childId;
        while(childId = task.get('children')[0]) {
            var child = this.get(childId);
            this.removeSubtreeRecurse(child);
        }
        
        // after the children are gone, remove the task itself
        this.remove(task);
    },
    
    // Mark the task and all below it finished, depth first recursively
    setIncompleteSubtree: function(task) {
        // recursively mark children finished
        var children = task.get('children');
        for (var i = 0; i < children.length; i++) {
            var child = this.get(children[i]);
            this.setIncompleteSubtree(child);
        }                    
        
        // after the children are set, set the task itself as finished
        task.setIncomplete();
    },

    // Mark the task and all below it finished, depth first recursively
    setCompletedSubtree: function(task) {
        // recursively mark children finished
        var children = task.get('children');
        for (var i = 0; i < children.length; i++) {
            var child = this.get(children[i]);
            this.setCompletedSubtree(child);
        }                    
        
        // after the children are gone, set the task itself as finished
        task.setCompleted();
    },
    
    // Return all items at the given level (distance from root)
    getAtLevel: function(level) {
        var collection = this;
        var atLevel = [];
        
        this.each(function(obj, key) {
            if (collection.getLevel(obj) === level) {
                atLevel.push(obj);
            }
        });
        
        return atLevel;
    },

    // Return the parent node of a given node
    getParent: function(node) {
        return this.get(node.get('parent'));
    },
    
    // Recursively calculate the level (how far below the root node) of the given node 
    getLevel: function(node) {
        // base case
        if ((node.get('parent') === -1) || (typeof node.get('parent') === 'undefined')) {
            return 0;
        }
        
        // recurse up one level
        return (this.getLevel(this.getParent(node)) + 1);
    },
    
    // Recursively calculates how many levels exist directly below a given node (how many levels of children it has)
    // Does not count minimized nodes
    getHeight: function(node) {
        var children = node.get('children');
        
        // base case
        if ((children.length === 0) || (node.get('minimized') === true)) {
            return 0;
        }
        
        // find height of highest child
        var highest = 0;
        for (var i in children) {
            var height = this.getHeight(this.get(children[i]));
            
            if (height > highest) {
                highest = height;
            }
        }
        
        // this node's height is highest child + 1
        return (highest + 1);
    },
    
    // Given two related nodes, returns their nearest common ancestor
    getNearestCommonAncestor: function(nodeA, nodeB) {
        var levelA = nodeA.get('level');
        var levelB = nodeB.get('level');
        
        // base case: nodes are the same node
        if (nodeA.get('id') === nodeB.get('id')) {
            return nodeA;
        }        
        
        // if nodes aren't at same level, recurse with lower one's parent
        if (levelA !== levelB) {
            if (levelA > levelB) {
                return this.getNearestCommonAncestor(nodeA, this.get(nodeB.get('parent')));
            }
        }
        
        // recurse with each node's parent
        return this.getNearestCommonAncestor(this.get(nodeA.get('parent')), this.get(nodeB.get('parent')));        
    }
});

// The main sandbox for manipulating tasks
var Multitasq_Sandbox = Backbone.View.extend({

    // The SVG element
    el: $("#content_tasksvg"),
    
    // the tasks collection
    tasks: null,

    // config
    taskWidth: 150,
    taskHeight: 60,
    taskSpacing: 20,
    taskLeftmost: Infinity, taskRightmost: 0,
    taskBottommost: 0,
    taskTitleLength: 18,
    scaleDownStep: 0.6,
    translation: 0,
    mousestopTimer: null,
    colorActiveFill: 'green',
    colorInactiveFill: '#ffffff',
    colorSelectedStroke: 'green',
    colorUnselectedStroke: '#afafaf',

    // init
    nearest: -1,
    
    events: {
        'mouseenter':                                   'sandboxEnter',
        'mouseleave':                                   'sandboxLeave',
        'mousemove':                                    'updateTaskSelected',
        'mouseenter #content_tasksvg_bg':               'sandboxBgEnter',
        'click #content_tasksvg_bg':                    'clickAdd',
        'click .content_tasksvg_task_close':            'clickRemove',
        'click .content_tasksvg_task_minimize':         'clickMinimize',
        'click .content_tasksvg_task_updown':           'clickUpdown',
        'click .content_tasksvg_task_text':             'clickReviveEdit',
        'click .content_tasksvg_task_box':              'clickReviveEdit',
        'click .content_tasksvg_task_textfield_submit': 'clickSubmit',
        'mouseenter .content_tasksvg_task_box':         'enterTask',
        'mouseenter .content_tasksvg_task_close':       'enterTask',
        'mouseenter .content_tasksvg_task_text':        'enterTask',
        'submit .content_tasksvg_task_textfield_form':  'clickSubmit',
        'keyup':                                        'keypress'
    },
    
    initialize: function(nodes) {
        // create our main collection of tasks
        this.tasks = new Multitasq_TaskList(this);
        
        /*mytasks.fetch({ 
            succes:    function() {
            alert("fetched");
            },
            error: function() {
                alert("failed");
            }
        });*/
        
        // Fill up tasks with our insta-data from PHP
        //this.tasks.reset(nodes);
        
        // Fill up the collection with data from localstorage if it exists
        this.tasks.fetch();

        // If there was no data in localstorage, reset and trigger default data creation
        if (!this.tasks.length) {
            this.tasks.reset();
        }
    },
    
    // Remove everything from the svg
    clear: function() {
        $(this.el).empty();
        
        // reset stored values
        this.taskLeftmost = Infinity;
        this.taskRightmost = 0;
        this.taskBottommost = 0;
        
        // restore the main group
        var group = document.createElementNS('http://www.w3.org/2000/svg','g');
        group.setAttribute('id', ('content_tasksvg_group'));
        $(this.el).append(group);
        
        // restore the background
        var bg = document.createElementNS('http://www.w3.org/2000/svg','rect');
        bg.setAttribute('id', ('content_tasksvg_bg'));
        bg.setAttribute('width', '100%');
        bg.setAttribute('height', '100%');
        $(group).append(bg);
    },
    
    /*** Event Functions  ***/
    
    // Handler for mouse over the sandbox
    sandboxEnter: function(e) {
        this.nearest = this.nearestTask((e.pageX), (e.pageY - $(this.el).offset().top));
        
        // visually show nearest task
        this.setTaskSelected(this.nearest);
    },
    
    // Handler for mouse leaving the sandbox
    sandboxLeave: function() {
        // remove visual nearest indicator and over indicator
        $('.content_tasksvg_task_box').css('stroke', '#afafaf');
        $('.content_tasksvg_task_box').css('fill', '#ffffff');
    },
    
    // Handler for entering the sandbox bg (can enter from edges or from task)
    sandboxBgEnter: function() {
        // set all tasks to normal fill color
        this.setTaskInactive();
    },
    
    // Update the position of the pending task based on the mouse position
    updateTaskSelected: function(e){
        // no need to update if we're outside the svg, or hovering over a task itself
        if ($('#content_tasksvg_bg:hover')) {            
            // get the dimensions of the viewBox and real SVG
            var widthSVG = $('#content').width();
            var heightSVG = $('#content').height();
            var widthViewBox = this.getViewBoxWidth();
            var heightViewBox = this.getViewBoxHeight();
            
            // convert real coords to viewBox coords
            var x = e.pageX * widthViewBox / widthSVG;
            var y = (e.pageY - $(this.el).offset().top) * heightViewBox / heightSVG;
            
            // find the point nearest to this in viewBox coords
            var nearestNew = this.nearestTask(x, y);
            
            // if the nearest task has changed
            if (nearestNew != this.nearest) {
                // update the visual selection
                this.setTaskSelected(nearestNew);
                
                // and update nearest
                this.nearest = nearestNew;
            }
        }
    },
    
    // Add a task nearest the cursor
     clickAdd: function() {
        // if a task is being edited, confirm the edit, don't add a task
        if ($('.content_tasksvg_task_textfield').length) {
            this.editTaskConfirmAll();
        }
        // can't add a task to a minimized parent
        else if (!this.tasks.get(this.nearest).get("minimized")) {
            // add a task whose parent is nearest to the mouse
            var id = this.tasks.newId();
            this.tasks.create({
                'id':         id,
                'parent':    this.nearest
            });
            
            // start editing the task
            this.editTask(id);
        }
    },    
    
    // X button click to complete/delete
    clickRemove: function(e) {
        var task = this.tasks.get($(e.target).parent().data('task'));

        // if the task is completed, then fully remove it
        if (task.get('completed')) {
            this.tasks.removeSubtree(task, this);
        }
        // if the task is not completed, just mark it as completed, but don't remove it
        else {
            this.tasks.setCompletedSubtree(task);
            this.tasks.collectionUpdated(this);
        }
    },
    
    // - button click to minimize/expand
    clickMinimize: function(e) {
        var task = this.tasks.get($(e.target).parent().data('task'));
        
        // if the task has no children, you cannot minimize/expand
        if (task.get("children").length > 0) {
            task.toggleMinimized();
            this.tasks.collectionUpdated(this);
        }
    },
    
    // updown arrow buttons to send a task to top or restore
    clickUpdown: function(e) {
        var task = this.tasks.get($(e.target).parent().data('task'));
        
        task.toggleUpdown();
        this.tasks.collectionUpdated(this);
    },
    
    // Handler for clicking a task, either edit it or bring it back from completed status
    clickReviveEdit: function(e) {
        var id = $(e.target).parent().data('task');
        var task = this.tasks.get(id);

        // the task's parent must not be completed
        if ((task.get('level') === 0) || !this.tasks.get(task.get('parent')).get('completed')) {
            // if the task is completed, bring it back to life
            if (task.get('completed')) {
                this.tasks.setIncompleteSubtree(task);
                this.tasks.collectionUpdated(this);
            }
            // if incomplete, edit the title
            else {
                // if we're already editing something, confirm that one first
                if ($('.content_tasksvg_task_textfield').length) {
                    this.editTaskConfirmAll();
                }
                this.editTask(id);
            }
        }
    },
    
    // Handler for submitting a task edit
    clickSubmit: function(e) {
        this.editTaskConfirmAll();
        
        // prevent the form from actually submitting    
        return false;
    },

    // Handler for hovering over any part of a task
    enterTask: function(e) {
        var id = $(e.target).data('id') ? $(e.target).data('task') : $(e.target).parent().data('task');
        this.setTaskActive(id);
    },
    
    // Read keypresses
    keypress: function(e) {
        // if the escape key is hit, cancel all edits
        if (e.keyCode === 27) {
            this.editTaskCancel();
        }
    },
    
    /*** End Event Functions ***/
    
    // click to edit task text
    editTask: function(id) {
        var label = $('.content_tasksvg_task_text.task' + id);
        var task = this.tasks.get(id);
        
        // remove the current text in the svg
        label.get(0).textContent = '';

        // create foreign object in svg
        var field = document.createElementNS('http://www.w3.org/2000/svg','foreignObject');
        field.setAttribute('class', 'content_tasksvg_task_textfield task'+label.parent().data('task'));
        field.setAttribute('data-task', label.parent().data('task'));
        field.setAttribute('x', label.attr('x'));
        field.setAttribute('y', (label.attr('y') - 20));
        field.setAttribute('width', (this.taskWidth - 10));
        field.setAttribute('height', '50');
        // and create its body
        var fieldBody = document.createElement('body');
        fieldBody.setAttribute('xmlns', 'http://www.w3.org/1999/xhtml');
        // create a form
        var fieldBodyForm = document.createElement('form');
        fieldBodyForm.setAttribute('class', 'content_tasksvg_task_textfield_form');
        // create the text input field
        var fieldBodyFormInput = document.createElement('input');
        fieldBodyFormInput.setAttribute('type', 'text');
        fieldBodyFormInput.setAttribute('value', task.get('title'));
        fieldBodyFormInput.setAttribute('style', ('width: ' + (this.taskWidth - 22) + 'px'));
        // create the submit button
        var fieldBodyFormSubmit = document.createElement('input');
        fieldBodyFormSubmit.setAttribute('type', 'submit');
        fieldBodyFormSubmit.setAttribute('value', 'Edit');
        fieldBodyFormSubmit.setAttribute('class', 'content_tasksvg_task_textfield_submit');
        fieldBodyFormSubmit.setAttribute('hidden', 'hidden');
        
        // stick everything together and put it in the DOM
        fieldBodyForm.appendChild(fieldBodyFormInput);
        fieldBodyForm.appendChild(fieldBodyFormSubmit);
        fieldBody.appendChild(fieldBodyForm);
        field.appendChild(fieldBody);
        $(this.el).append(field);

        // select the input text for the user
        var input = $('.content_tasksvg_task_textfield.task'+label.parent().data('task')).find('input[type=text]').get(0);
        input.select();
    },
    
    // Cancel all open task edits without saving
    editTaskCancel: function() {
        if ($('.content_tasksvg_task_textfield').length) {
            var sandbox = this;
            $('.content_tasksvg_task_textfield').each(function() {
                // get the task's id
                var id = $(this).data('task');
        
                // revert to the title stored in data
                var label = $('.content_tasksvg_task_text.task' + id);
                label.get(0).textContent = sandbox.tasks.get(id).get('title').substring(0, sandbox.taskTitleLength) + "...";
        
                // remove the textfield
                $(this).remove();
            });
        }
    },
    
    // Confirm all open task edits
    editTaskConfirmAll: function() {
        var sandbox = this;
        if ($('.content_tasksvg_task_textfield').length) {
            $('.content_tasksvg_task_textfield').each(function() {
                var id = $(this).data('task');
                var input = $(this).find('input[type=text]');
                var task = sandbox.tasks.get(id);
        
                // remove the textfield
                $(this).remove();

                // write the update and refresh the view
                task.save({'title': $(input).val()});
            });
        }

        // refresh the view
        this.tasks.collectionUpdated(this);
    },
    
    // Set a task as visually active (and clear any other active tasks)
    setTaskActive: function(id) {
        var task = this.tasks.get(id);
        
        // set all as inactive
        $('.content_tasksvg_task_box').css('fill', this.colorInactiveFill);
        
        // set given as active by...
        // coloring it
        $('.content_tasksvg_task_box.task' + id).css('fill', this.colorActiveFill);
        // and showing the full title
//        $('.content_tasksvg_task_text.task' + id).text(task.get('title'));
//        $('.content_tasksvg_task_box.task' + id).attr('width', '200');
    },
    
    // Set a task as visually inactive, or if no id given, set all inactive
    setTaskInactive: function(id) {
        var whichSelect = (typeof id === 'undefined') ? '' : ('.task' + id);
        
        // make it normal color
        $('.content_tasksvg_task_box' + whichSelect).css('fill', '#ffffff');
        
        // limit the title length again
        $('.content_tasksvg_task_text' + whichSelect).text(text);
        if (typeof id !== 'undefined') {
            var task = this.tasks.get(id);
            var text = task.get('title').substring(0, this.taskTitleLength) + "...";
            $('.content_tasksvg_task_text' + whichSelect).text(text);
        }
    },
    
    // Set a task as visually selected (and clear any other selected tasks)
    setTaskSelected: function(id) {
        // set all as unselected
        $('.content_tasksvg_task_box').css('stroke', this.colorUnselectedStroke);
        
        // set given as selected
        $('.content_tasksvg_task_box.task'+id).css('stroke', this.colorSelectedStroke);
    },
    
    // Set a task as visually unselected, or if no id given, set all unselected
    setTaskUnselected: function(id) {
        var whichSelect = (typeof id === 'undefined') ? '' : ('.task' + id);
        $('.content_tasksvg_task_box' + whichSelect).css('stroke', this.colorUnselectedStroke);
    },
    
    // Remove a task from the view
/*    removeTask: function(which) {
        // remove the task from its parent's children data
        var parent = $(".content_tasksvg_task.task"+which).data("parent");
        var children = $(".content_tasksvg_task.task"+parent).data("children");
        var index = children.indexOf(which);
        children.splice(index, 1);
        $(".content_tasksvg_task.task"+$(".content_tasksvg_task.task"+which).data("parent")).data("children", children);
        
        // physically remove the task from the dom and from our count
        $(".content_tasksvg_task.task"+which).remove();
        
        // reposition its siblings and their children
        if (parent !== -1) {
            this.restructureTree(parent);
        }
    },
*/    
    // clear the view and render everything in this.tasks
    render: function() {
        var sandbox = this;
    
        // clear anything existing in the view
        this.clear();
        
        // create and reposition the nodes properly
        this.renderSubtree(this.tasks.top);
        this.bushifyTree(this.tasks.top);
        
        // if we exceeded the screen, shrink and rerender
        var viewBoxWidthScaled = this.getViewBoxWidth() * this.scaleDownStep;
        var viewBoxHeightScaled = this.getViewBoxHeight() * this.scaleDownStep;
        var treeWidth = this.taskRightmost - this.taskLeftmost;
        var taskBottomBuff = this.taskBottommost + this.taskSpacing * 2;
        if ((this.taskLeftmost <= 0) || (this.taskRightmost > this.getViewBoxWidth()) || (taskBottomBuff > this.getViewBoxHeight())) {
            sandbox.scale(1 / this.scaleDownStep);
        }
        // otherwise if we can grow by one step and still fit on screen, without getting ugly huge, scale and rerender
        else if ((treeWidth < viewBoxWidthScaled) && (taskBottomBuff < viewBoxHeightScaled) && ((this.taskWidth / viewBoxWidthScaled) < 0.12)) {
            sandbox.scale(this.scaleDownStep);
        }
    },
    
    // breadth first recursively renders a subtree
    renderSubtree: function(id) {
        var task = this.tasks.get(id);
        
        // render this task
        var taskview = new Multitasq_TaskView(task);
        taskview.render(this);
        
        // render this task's children if not minimized
        if (!task.get("minimized")) {
            var children = task.get("children");
            for (var i in children) {
                this.renderSubtree(children[i]);
            }
            
            // if no children, check if bottommost and record if so
            if (!children.length) {
                var bottom = parseInt($(".content_tasksvg_task_box.task"+id).attr("y")) + this.taskHeight;
                if (bottom > this.taskBottommost) {
                    this.taskBottommost = bottom;
                }
            }
        }
    },
    
    // depth-first recursively spread out nodes to prevent overlap
    // returns left/right limits, calculated as distance from center of node
    bushifyTree: function(top) {
        var children = $(".content_tasksvg_task.task"+top).data("children") || [];

        // base case spacing: 0 children
        var limits = {left: (this.taskWidth / 2 + this.taskSpacing / 2), right: (this.taskWidth / 2 + this.taskSpacing / 2)};
        
        if (children.length > 0) {
            // get limits of children and overall width
            var limitsChildren = [];
            var width = 0;
            for (var i = 0; i < children.length; i++) {
                var limitsChild = this.bushifyTree(children[i]);
                
                limitsChildren.push(limitsChild);
                
                width = width + limitsChild.left + limitsChild.right;
            }
            
            // set the limits of this parent
            limits = {left: width / 2, right: width / 2};
            var center = parseInt($(".content_tasksvg_task_box.task"+top).attr("x")) + this.taskWidth / 2;
            var limitsAbs = {left: (center - limits.left), right: (center + limits.right)};
            
            // check if it's left or right overall and keep track of the position if so
            if (limitsAbs.left < this.taskLeftmost) {
                this.taskLeftmost = limitsAbs.left;
            }
            if (limitsAbs.right > this.taskRightmost) {
                this.taskRightmost = limitsAbs.right;
            }
            
            // position children if more than 1 child
            if (children.length > 1) {
                var limitLeft = width / 2 * -1 + this.taskWidth / 2;
            
                for (i = 0; i < children.length; i++) {
                    // reposition this child and its subtree
                    var goto = limitLeft + limitsChildren[i].left - this.taskWidth / 2;
                
                    this.translateTreeBy(children[i], goto);
                
                    limitLeft = limitLeft + limitsChildren[i].left + limitsChildren[i].right;
                }
            }
        }
        
        return limits;
    },
    
    // recursively translate the x position of an entire tree/subtree by the given amount
    translateTreeBy: function(id, x) {
        var children =  $(".content_tasksvg_task.task"+id).data("children");
        var xOld = parseInt($(".content_tasksvg_task_box.task"+id).attr('x'));
        
        // move the top node
        this.moveTaskTo(id, (xOld + x));
        
        // move its children if it has any
        if (typeof children !== 'undefined') {
            for (var i = 0; i < children.length; i++) {
                this.translateTreeBy(children[i], x);
            }
        }
    },
    
    // scales the svg by the given amount
    scale: function(factor) {
        // get the viewBox width and height of the svg
        var width = this.getViewBoxWidth();
        var height = this.getViewBoxHeight();
        
        // scale these parameters
        width = Math.round(width * factor);
        height = Math.round(height * factor);

        // set these as viewBox on the SVG
        $(this.el)[0].setAttribute('viewBox', '0 0 ' + width + ' ' + height);

        // rerender the view in order to center it
        this.render();
    },
    
    // moves given task's rect, text, and connectors to given X coordinate
    moveTaskTo: function(which, where) {
        $(".content_tasksvg_task_box.task"+which).get(0).setAttribute('x', where);
        $(".content_tasksvg_task_text.task"+which).get(0).setAttribute('x', (where + 5));
        $(".content_tasksvg_task_close.task"+which).get(0).setAttribute('x', (where + this.taskWidth - 16));
        $(".content_tasksvg_task_updown.task"+which).get(0).setAttribute('x', (where + this.taskWidth - 54));
        $(".content_tasksvg_task_minimize.task"+which).get(0).setAttribute('x', (where + this.taskWidth - 32));
        // move connector based on parent's position
        var parentPos = parseInt($('.content_tasksvg_task_box.task'+$('.content_tasksvg_task.task'+which).data('parent')).attr('x'));
        $(".content_tasksvg_connector.task"+which).get(0).setAttribute('x1', (parentPos + (this.taskWidth / 2)));
        $(".content_tasksvg_connector.task"+which).get(0).setAttribute('x2', (where + (this.taskWidth / 2)));
        // move the edit textfield if it's open
        if ($('.content_tasksvg_task_textfield.task'+which).length) {
            $('.content_tasksvg_task_textfield.task'+which).get(0).setAttribute('x', (where + 5));
        }
    },
    
    // returns the id of the non-pending task nearest and above the given coordinates O(n)
    nearestTask: function(x, y) {
        var nearestTask;
        var nearestDistance = Infinity;
        var sandbox = this;
        $('.content_tasksvg_task:not(.pending) > .content_tasksvg_task_box').each( function() {
            // find the point on the task nearest to x,y
            var taskNearest = sandbox.nearestTaskPoint($(this).parent().data('task'), x, y);
            
            // calculate distance to this point
            var currentDistance = sandbox.distance(taskNearest[0], taskNearest[1], x, y);
            
            // if this distance is the closest so far, save it
            if ((currentDistance < nearestDistance) && (y > taskNearest[1])) {
                nearestDistance = currentDistance;
                nearestTask = $(this).parent().data('task');
            }
        });
        
        // If nothing above, return the root
        if (typeof nearestTask === 'undefined') {
            nearestTask = this.tasks.top;
        }
        return nearestTask;
    },
    
    // returns the point on a task nearest the given coordinates O(1)
    nearestTaskPoint: function(id, x, y) {
        var taskDom = $('.content_tasksvg_task_box.task' + id);
        
        // find the extremeties of the task
        var furthestNorth = parseInt($(taskDom).attr('y'));
        var furthestEast = parseInt($(taskDom).attr('x')) + this.taskWidth;
           var furthestSouth = parseInt($(taskDom).attr('y')) + this.taskHeight;
        var furthestWest = parseInt($(taskDom).attr('x'));
        
        // get the nearest x coordinate on the task
        var nearestX;
        if (x < furthestWest) {
            nearestX = furthestWest;
        }
        else if (x > furthestEast) {
            nearestX = furthestEast;
        }
        else {
            nearestX = x;
        }
        
        // get the nearest y coordinate on the task
        var nearestY;
        if (y < furthestNorth) {
            nearestY = furthestNorth;
        }
        else if (y > furthestSouth) {
            nearestY = furthestSouth;
        }
        else {
            nearestY = y;
        }
        
        return [nearestX, nearestY];
    },
    
    // gets the height of the SVG according to its viewBox (if it exists)
    getViewBoxWidth: function() {
        // if there is no viewBox yet, just return the size of the container
        if ($(this.el)[0].getAttribute('viewBox') === null) {
            return $('#content').width();
        }
        else {
            var params = $(this.el)[0].getAttribute('viewBox');
            // remove min-x
            params = params.substring(params.indexOf(' ') + 1, params.length);
            // remove min-y
            params = params.substring(params.indexOf(' ') + 1, params.length);
            // get width
            return parseInt(params.substring(0, params.indexOf(' ')));
        }
    },
    
    // gets the height of the SVG according to its viewBox (if it exists)
    getViewBoxHeight: function() {
        // if there is no viewBox yet, just return the size of the container
        if ($(this.el)[0].getAttribute('viewBox') === null) {
            return $('#content').height();
        }
        else {
            var params = $(this.el)[0].getAttribute('viewBox');
            // remove min-x
            params = params.substring(params.indexOf(' ') + 1, params.length);
            // remove min-y
            params = params.substring(params.indexOf(' ') + 1, params.length);
            // remove width, leaving you with height
            return parseInt(params.substring(params.indexOf(' ') + 1, params.length));
        }
    },
   
    // Math functions that I'd like to move to a separate js file!
    getTaskMidX: function(which) {
        if (which === -1) {
            return 0;
        }
        else {
            return parseInt($(".content_tasksvg_task_box.task"+which).attr('x')) + (parseInt($(".content_tasksvg_task_box.task"+which).attr('width')) / 2);
        }
    },
    getTaskMidBotY: function(which) {
        if (which === -1) {
            return 0;
        }
        else {
            return parseInt($(".content_tasksvg_task_box.task"+which).attr('y')) + parseInt($(".content_tasksvg_task_box.task"+which).attr('height'));
        }
    },
    getTaskMidTopY: function(which) {
        return parseInt($(".content_tasksvg_task_box.task"+which).attr('y'));
    },
    // distance between two points!
    distance: function(x1, y1, x2, y2) {
        return Math.sqrt(Math.pow((x1 - x2), 2) + Math.pow((y1 - y2), 2));
    },
    
    // Cool jQuery SVG functions
    // jQuery's removeClass doesn't work for SVG, but this does!
    removeClassSVG: function(obj, remove) {
        var classes = $(obj).attr('class');
        var index = classes.search(remove);
        
        // string manipulation to remove the class
        classes = classes.substring(0, index) + classes.substring((index + remove.length), classes.length);
        
        // set the new string as the object's class
        $(obj).attr('class', classes);
    },
    // jQuery's hasClass doesn't work for SVG, but this does!
    hasClassSVG: function(obj, has) {
        var classes = $(obj).attr('class');
        var index = classes.search(has);
        
        if (index === -1) {
            return false;
        }
        else {
            return true;
        }
    }
});

// An individual task in the svg
var Multitasq_TaskView = Backbone.View.extend({

    // The SVG element
    el: null,
    
    // the task for this view
    task: null,
    
    // config

    // init
    
    events: {
    },
    
    // just initializes the variables here, doesn't render
    initialize: function(task) {
        this.task = task;
        this.el = $(".content_tasksvg_task.task" + task.get('id'));
    },
    
    render: function(sandbox) {
        var id = this.task.get('id');
        var parent = this.task.get('parent');
        var pending = this.task.get('dontSync') ? true : false;
        
        var text = this.task.get('title');
        
        // limit the length of the title text
        if (text.length > sandbox.taskTitleLength) {
            text = text.substring(0, (sandbox.taskTitleLength - 1));
            text = text + "...";
        }

        var opacity = this.task.get('completed') ? 0.3 : 1;
        
        var x = (sandbox.getViewBoxWidth() / 2 - sandbox.taskWidth / 2);
        var y = 4;
        var level = 0;

        // if we're not adding the very first task
        if ((parent != -1) && (!this.task.get("upped"))) {
            y = parseInt($(".content_tasksvg_task_box.task"+parent).attr("y")) + 100;
            
            level = parseInt(sandbox.tasks.get(parent).get('level')) + 1;
        }

        // create the group for the whole task
        var group = document.createElementNS('http://www.w3.org/2000/svg','g');
        var pendingClass = pending ? ' pending' : '';
        group.setAttribute('class', ('content_tasksvg_task task'+id+pendingClass));
        group.setAttribute('style', 'opacity: ' + opacity + ';');

        // create the rect
        var taskBox = document.createElementNS('http://www.w3.org/2000/svg','rect');
        taskBox.setAttribute('class', ('content_tasksvg_task_box task'+id));
        taskBox.setAttribute('x', x);
        taskBox.setAttribute('y', y);
        taskBox.setAttribute('rx', '10');
        taskBox.setAttribute('ry', '10');
        taskBox.setAttribute('width', sandbox.taskWidth);
        taskBox.setAttribute('height', sandbox.taskHeight);
        group.appendChild(taskBox);
        
        // create the title text
        var taskText = document.createElementNS('http://www.w3.org/2000/svg','text');
        taskText.setAttribute('class', ('content_tasksvg_task_text task'+id));
        taskText.setAttribute('x', (x + 5));
        taskText.setAttribute('y', (y + 40));
        var textNode = document.createTextNode(text);
        taskText.appendChild(textNode);
        group.appendChild(taskText);
        
        // create the title text via foreignobject
        /*
        var title = document.createElementNS('http://www.w3.org/2000/svg','foreignObject');
        title.setAttribute('class', ('content_tasksvg_task_text task'+id));
        title.setAttribute('x', (x + 5));
        title.setAttribute('y', (y + 10));
        title.setAttribute('height', 40);
        title.setAttribute('width', sandbox.taskWidth - 10);
        // and create its body
        var titleBody = document.createElement('body');
        titleBody.setAttribute('xmlns', 'http://www.w3.org/1999/xhtml');
        // and put a p tag in there
        var titleBodyP = document.createElement('p');
        titleBodyP.setAttribute('style', 'color: #cfcfcf;');
        titleBodyP.innerHTML = this.task.get('title');
        // and append everything
        titleBody.appendChild(titleBodyP);
        title.appendChild(titleBody);
        group.appendChild(title);
        */
        
        // create the up/down arrrow button if not the absolute top node
        if (parent != -1) {
            var updown = document.createElementNS('http://www.w3.org/2000/svg','text');
            updown.setAttribute('class', ('content_tasksvg_task_updown task'+id));
            updown.setAttribute('x', (x + sandbox.taskWidth - 54));
            updown.setAttribute('y', (y + 16));
            updown.setAttribute('textLength', 0);
            var updownText = document.createTextNode((this.task.get("id") == sandbox.tasks.top) ? '↓' : '↑');
            updown.appendChild(updownText);
            group.appendChild(updown);
        }
                
        // create the -/+ minimize button
        var minimize = document.createElementNS('http://www.w3.org/2000/svg','text');
        minimize.setAttribute('class', ('content_tasksvg_task_minimize task'+id));
        minimize.setAttribute('x', (x + sandbox.taskWidth - 36));
        minimize.setAttribute('y', (y + 16));
        minimize.setAttribute('textLength', 0);
        var minimizeText = document.createTextNode(this.task.get("minimized") ? '+' : '-');
        minimize.appendChild(minimizeText);
        group.appendChild(minimize);
        
        // create the X close button
        var close = document.createElementNS('http://www.w3.org/2000/svg','text');
        close.setAttribute('class', ('content_tasksvg_task_close task'+id));
        close.setAttribute('x', (x + sandbox.taskWidth - 16));
        close.setAttribute('y', (y + 16));
        close.setAttribute('textLength', 20);
        var closeText = document.createTextNode('X');
        close.appendChild(closeText);
        group.appendChild(close);
        
        // create the connector to its parent (if it has one)
        if ((parent != -1) && (!this.task.get("upped"))) {
            var connect = document.createElementNS('http://www.w3.org/2000/svg','line');
            connect.setAttribute('class', 'content_tasksvg_connector task'+parent+' task'+id);
            connect.setAttribute('x1', sandbox.getTaskMidX(parent));
            connect.setAttribute('y1', sandbox.getTaskMidBotY(parent));
            connect.setAttribute('x2', (x + (sandbox.taskWidth / 2)));
            connect.setAttribute('y2', y);
            group.appendChild(connect);
        }

        // put it in the dom
        $("#content_tasksvg_group").append(group);

        // set data attributes
        $('.content_tasksvg_task.task'+id).data('task', id);
        $('.content_tasksvg_task.task'+id).data('parent', parent);
        $('.content_tasksvg_task.task'+id).data('children', this.task.get('minimized') ? [] : this.task.get('children'));
        $('.content_tasksvg_task.task'+id).data('level', level);
    }
});

$(function(){
    // create the app
    var multitasq = new Multitasq_Sandbox();

    // help button listener
    $(".helpToggle").on("click", function() {
        if ($("#content_overlay").css("display") == "block") {
            multitasq.render();
            $("#content_tasksvg").show();
            $("#content_overlay").hide();
        }
        else {
            multitasq.clear();
            $("#content_tasksvg").hide();
            $("#content_overlay").show();
        }
    });
});
